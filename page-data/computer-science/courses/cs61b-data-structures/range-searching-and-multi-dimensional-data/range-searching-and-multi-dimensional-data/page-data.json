{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/computer-science/courses/cs61b-data-structures/range-searching-and-multi-dimensional-data/range-searching-and-multi-dimensional-data","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Range Searching and Multi Dimensional Data\"), mdx(\"h2\", null, \"Intro\"), mdx(\"p\", null, \"Let us consider a use case where we have a bunch of data points corresponding to\\nX-Y coordinates of celestial bodies orbiting a sun, and we need to calculate the\\nnumber of these bodies in a certain 2D range of coordinates, as shown below. Or\\nwe might need to find the closest body to a particular one.\"), mdx(\"p\", null, \"These operations can be listed as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"2D range searching\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Nearest neighbors\")), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/9b2f4b4b1fa8c9e244adf09c80cb4ce2/bodies.png\",\n    \"alt\": \"bodies\"\n  }), \".\"), mdx(\"p\", null, \"If the data is stored as a hash table (the hashcode could be implemented using x\\nand y coordinates), both operations will be \\u0398(N), since we would have to iterate\\nover all items in the hash table. Let's simplify this problem by partitioning\\nthe 2D space into bins.\"), mdx(\"h2\", null, \"Uniform Partitioning\"), mdx(\"p\", null, \"The idea is to leverage the fact that by knowing the X and Y position, we can\\nknow which bucket of the hash table a particular point will fall in.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/1d31d2cff45810ed781f0963bcc1b5b4/bodies-partitioned.png\",\n    \"alt\": \"bodies-partitioned\"\n  })), mdx(\"p\", null, \"Assuming the points are evenly spread out, this would reduce the number of\\npoints we would have to look up for both operations. However, runtimes for\\nboth will still be \\u0398(N).\"), mdx(\"h2\", null, \"Trees vs Hash Tables\"), mdx(\"p\", null, \"Let's think about the nature of these two data structures for this particular\\nproblem. Search trees are all about order. As such, finding the minimum item in\\na BST is \\u0398(log(N)), whereas, it's \\u0398(N) in a hash table. We can make use of this\\nordered nature of search trees to improve the performance of the spatial\\noperations we're dealing with.\"), mdx(\"h2\", null, \"Building Trees of Two Dimensional Data\"), mdx(\"p\", null, \"We need some way to compare these 2D points for storing them in a BST. These\\npoints have X and Y coordinates, and we could either one of them to compare\\npoints. But, we would have to choose either one of them, and stick with it.\\nLet's consider an example of 2 2D points.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/f644baa90d9947f679b0b5a4297663b7/2d-bst.png\",\n    \"alt\": \"2d-bst\"\n  })), mdx(\"p\", null, \"Based on whether we're using X or Y coordinates to compare, we'd end up with\\neither one of the following BSTs.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/b141c504d2cceb658fa316d9f1a883ae/2d-trees.png\",\n    \"alt\": \"2d-trees\"\n  })), mdx(\"p\", null, \"With both BST, we lose some representation of the spatial structure (since we're\\nonly using one dimension).\"), mdx(\"p\", null, \"Let's see this in action. We'll see two trees representing a dataset of 6 2D\\npoints.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"put((-1, -1), A)\\nput(( 2,  2), B)\\nput(( 0,  1), C)\\nput(( 1,  0), D)\\nput((-2, -2), E)\\nput((-3, 2.5), F)\"))), mdx(\"p\", null, \"Here's how they look in a 2D representation.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/10ea8ebd38de8b07db6e1e52aa71536d/6-points-2D.png\",\n    \"alt\": \"6-points-2D\"\n  })), mdx(\"p\", null, \"If we use the x-coordinate to compare, we get the following tree.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/b54d2b157544f0fbdae1cc139e304341/6-points-X-BST.png\",\n    \"alt\": \"6-points-X-BST\"\n  })), mdx(\"p\", null, \"This is better than the original hash table based approach for certain\\noperations. Suppose we want find out the points that have X coordinate less than\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-1.5\"), \". To do this we only need to look at the left hand child of the node \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \"\\nin the BST, and we can discard the right hand child completely. This process of\\ncutting off tree search is called \\\"pruning\\\".\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/406054405c7054a22aeb8fe8ad15db65/6-points-X-pruning.png\",\n    \"alt\": \"6-points-X-pruning\"\n  })), mdx(\"p\", null, \"However, this won't work if we build the BST by comparing Y coordinates.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/e5bf1d51ea299175c2a3a9308c2ff547/6-points-Y-pruning.png\",\n    \"alt\": \"6-points-Y-pruning\"\n  })), mdx(\"p\", null, \"This shows the limitations of using just one coordinate to build the BST.\\nFortunately, we can do better than this.\"), mdx(\"h2\", null, \"QuadTree\"), mdx(\"p\", null, \"We can improve on the previous idea by building a search tree where every node\\nhas 4 neighbors, corresponding to northwest, northeast, southwest, and southeast\\ndirections.\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vR79QZf2x_G4i8uTgbhTPL6__gXj4q_UohvBg42g0zYzyQLKal9MUqiCAGWsJg85BJ6l4CNhOt_P3fI/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"p\", null, \"As with regular BSTs, the order of insertion will determine the structure of the\\ntree. Quadtrees are, in fact, spatial partitioning in disguise. The previous\\napproach resulted in a uniform grid of rectangular regions, whereas we quadtrees\\nwe get what is called as hierarchical partitioning where each node \\\"owns\\\" 4\\nsubspaces.  Also, space is more finely divided in regions where there are more\\npoints.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/2c7f109d90b0bf5e5cf6bf48e57d8caf/quadtree-vs-uniform-partitioning.png\",\n    \"alt\": \"quadtree-vs-uniform-partitioning\"\n  })), mdx(\"h3\", null, \"Range Search\"), mdx(\"p\", null, \"Let's see how the quadtree helps us out with the range search operation.\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vThT7dHKwj-8Zxkhdl_sRjRroEGTwSoq8yqgBqyNMuou7QbsBfXxjaDC-ZQffdYz0emOFkpM637reEB/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"p\", null, \"As seen in the video, the structure of the quadtree enabled us to prune links\\nmuch more efficiently than the uniform partitioning approach.\"), mdx(\"h2\", null, \"KD Tree\"), mdx(\"p\", null, \"k-d trees are an extension of the previous idea, one that handles arbitray\\nnumber of dimensions. Let's see them in action using 2 dimensional data for the\\nsake of simplicity. \"), mdx(\"p\", null, \"For the case of 2 dimensions, the basic idea is that the root partitions the\\nentire space into left and right (ie, by the x dimension). All depth 1 nodes partition\\nthe subspace into up and down (ie, by the y dimension). We keep on cycling\\nthrough the dimensions at each subsequent level. \"), mdx(\"h3\", null, \"Insertion\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vTpwAIEkib5GO3gztO8kBGMseFofEiyhdV-ODGfhXUeBOPU1Gn3f-Z3mkKx5SffaxzJJmGDIrVpR4Sa/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"p\", null, \"!!! note \\\"We have to break ties somehow. We'll do that by saying that items that are equal in one dimension go off to the right child of each node.\\\"\"), mdx(\"h3\", null, \"Nearest Neighbor\"), mdx(\"p\", null, \"Searching for a node in a k-d tree is similar to a quadtree, with the difference\\nthat each node in a k-d tree owns 2 subspaces instead of 4.\"), mdx(\"p\", null, \"The intuition for finding the nearest neighbor using a k-d tree is that at any\\nnode, we want to look at the \\\"good\\\" side of its subtree before looking at the\\n\\\"bad\\\" side.\"), mdx(\"p\", null, \"Let's understand that through a demo. Suppose we have the following k-d tree,\\nand we need to find the node nearest to the point (0, 7).\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/f9ed723b938b74ead2ce990878ea4f98/kd-tree-nearest-1.png\",\n    \"alt\": \"kd-tree-nearest-1\"\n  })), mdx(\"p\", null, \"The same tree in 2D representation is as follows.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/1c5ed7461d2be9dfa2cd1f2fe4a06ff7/kd-tree-nearest-2.png\",\n    \"alt\": \"kd-tree-nearest-2\"\n  })), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vT_7Xrc2N4rd9r6Otp2SFZGcUqICylgUenL6meBk-iLG3k9ep7uH35KkcsF7upHSwYv9lVU-9ecfriC/embed?start=false&loop=false&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[],"inboundReferences":[{"contextLine":"- [[range-searching-and-multi-dimensional-data]]","referrer":{"parent":{"id":"7a2ed90b-bf85-5596-8620-2b3708fa9e83","fields":{"slug":"/computer-science/courses/cs61b-data-structures/cs61b-data-structures","title":"CS61B Data Structures"}}}}]},"fields":{"slug":"/computer-science/courses/cs61b-data-structures/range-searching-and-multi-dimensional-data/range-searching-and-multi-dimensional-data","title":"Range Searching and Multi Dimensional Data"}}},"pageContext":{"id":"5620fc6d-d945-5c3f-8536-fb390080d9a8","refWordMdxSlugDict":{}}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}