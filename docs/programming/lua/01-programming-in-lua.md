Programming In Lua
===

Links
---

- [:fontawesome-solid-book: Book](https://www.lua.org/pil/contents.html)


Chapters Checklist
---

- [ ] Part I The Language
- [ ] 1 – Getting Started
    - [ ] 1.1 – Chunks
    - [ ] 1.2 – Global Variables
    - [ ] 1.3 – Some Lexical Conventions
    - [ ] 1.4 – The Stand-Alone Interpreter
- [ ] 2 – Types and Values
    - [ ] 2.1 – Nil
    - [ ] 2.2 – Booleans
    - [ ] 2.3 – Numbers
    - [ ] 2.4 – Strings
    - [ ] 2.5 – Tables
    - [ ] 2.6 – Functions
    - [ ] 2.7 – Userdata and Threads
- [ ] 3 – Expressions
    - [ ] 3.1 – Arithmetic Operators
    - [ ] 3.2 – Relational Operators
    - [ ] 3.3 – Logical Operators
    - [ ] 3.4 – Concatenation
    - [ ] 3.5 – Precedence
    - [ ] 3.6 – Table Constructors
- [ ] 4 – Statements
    - [ ] 4.1 – Assignment
    - [ ] 4.2 – Local Variables and Blocks
    - [ ] 4.3 – Control Structures
    - [ ] 4.3.1 – if then else
    - [ ] 4.3.2 – while
    - [ ] 4.3.3 – repeat
    - [ ] 4.3.4 – Numeric for
    - [ ] 4.3.5 – Generic for
    - [ ] 4.4 – break and return
- [ ] 5 – Functions
    - [ ] 5.1 – Multiple Results
    - [ ] 5.2 – Variable Number of Arguments
    - [ ] 5.3 – Named Arguments
- [ ] 6 – More about Functions
    - [ ] 6.1 – Closures
    - [ ] 6.2 – Non-Global Functions
    - [ ] 6.3 – Proper Tail Calls
- [ ] 7 – Iterators and the Generic for
    - [ ] 7.1 – Iterators and Closures
    - [ ] 7.2 – The Semantics of the Generic for
    - [ ] 7.3 – Stateless Iterators
    - [ ] 7.4 – Iterators with Complex State
    - [ ] 7.5 – True Iterators
- [ ] 8 – Compilation, Execution, and Errors
    - [ ] 8.1 – The require Function
    - [ ] 8.2 – C Packages
    - [ ] 8.3 – Errors
    - [ ] 8.4 – Error Handling and Exceptions
    - [ ] 8.5 – Error Messages and Tracebacks
- [ ] 9 – Coroutines
    - [ ] 9.1 – Coroutine Basics
    - [ ] 9.2 – Pipes and Filters
    - [ ] 9.3 – Coroutines as Iterators
    - [ ] 9.4 – Non-Preemptive Multithreading
- [ ] 10 – Complete Examples
    - [ ] 10.1 – Data Description
    - [ ] 10.2 – Markov Chain Algorithm
- [ ] Part II Tables and Objects
- [ ] 11 – Data Structures
    - [ ] 11.1 – Arrays
    - [ ] 11.2 – Matrices and Multi-Dimensional Arrays
    - [ ] 11.3 – Linked Lists
    - [ ] 11.4 – Queues and Double Queues
    - [ ] 11.5 – Sets and Bags
    - [ ] 11.6 – String Buffers
- [ ] 12 – Data Files and Persistence
    - [ ] 12.1 – Serialization
    - [ ] 12.1.1 – Saving Tables without Cycles
    - [ ] 12.1.2 – Saving Tables with Cycles
- [ ] 13 – Metatables and Metamethods
    - [ ] 13.1 – Arithmetic Metamethods
    - [ ] 13.2 – Relational Metamethods
    - [ ] 13.3 – Library-Defined Metamethods
    - [ ] 13.4 – Table-Access Metamethods
    - [ ] 13.4.1 – The __index Metamethod
    - [ ] 13.4.2 – The __newindex Metamethod
    - [ ] 13.4.3 – Tables with Default Values
    - [ ] 13.4.4 – Tracking Table Accesses
    - [ ] 13.4.5 – Read-Only Tables
- [ ] 14 – The Environment
    - [ ] 14.1 – Accessing Global Variables with Dynamic Names
    - [ ] 14.2 – Declaring Global Variables
    - [ ] 14.3 – Non-Global Environments
- [ ] 15 – Packages
    - [ ] 15.1 – The Basic Approach
    - [ ] 15.2 – Privacy
    - [ ] 15.3 – Packages and Files
    - [ ] 15.4 – Using the Global Table
    - [ ] 15.5 – Other Facilities
- [ ] 16 – Object-Oriented Programming
    - [ ] 16.1 – Classes
    - [ ] 16.2 – Inheritance
    - [ ] 16.3 – Multiple Inheritance
    - [ ] 16.4 – Privacy
    - [ ] 16.5 – The Single-Method Approach
- [ ] 17 – Weak Tables
    - [ ] 17.1 – Memoize Functions
    - [ ] 17.2 – Object Attributes
    - [ ] 17.3 – Revisiting Tables with Default Values
- [ ] Part III · The Standard Libraries
- [ ] 18 – The Mathematical Library
- [ ] 19 – The Table Library
    - [ ] 19.1 – Array Size
    - [ ] 19.2 – Insert and Remove
    - [ ] 19.3 – Sort
- [ ] 20 – The String Library
    - [ ] 20.1 – Pattern-Matching Functions
    - [ ] 20.2 – Patterns
    - [ ] 20.3 – Captures
    - [ ] 20.4 – Tricks of the Trade
- [ ] 21 – The I/O Library
    - [ ] 21.1 – The Simple I/O Model
    - [ ] 21.2 – The Complete I/O Model
    - [ ] 21.2.1 – A Small Performance Trick
    - [ ] 21.2.2 – Binary Files
    - [ ] 21.3 – Other Operations on Files
- [ ] 22 – The Operating System Library
    - [ ] 22.1 – Date and Time
    - [ ] 22.2 – Other System Calls
- [ ] 23 – The Debug Library
    - [ ] 23.1 – Introspective Facilities
    - [ ] 23.1.1 – Accessing Local Variables
    - [ ] 23.1.2 – Accessing Upvalues
    - [ ] 23.2 – Hooks
    - [ ] 23.3 – Profiles
- [ ] Part IV · The C API
- [ ] 24 – An Overview of the C API
    - [ ] 24.1 – A First Example
    - [ ] 24.2 – The Stack
    - [ ] 24.2.1 – Pushing Elements
    - [ ] 24.2.2 – Querying Elements
    - [ ] 24.2.3 – Other Stack Operations
    - [ ] 24.3 – Error Handling with the C API
    - [ ] 24.3.1 – Error Handling in Application Code
    - [ ] 24.3.2 – Error Handling in Library Code
- [ ] 25 – Extending your Application
    - [ ] 25.1 – Table Manipulation
    - [ ] 25.2 – Calling Lua Functions
    - [ ] 25.3 – A Generic Call Function
- [ ] 26 – Calling C from Lua
    - [ ] 26.1 – C Functions
    - [ ] 26.2 – C Libraries
- [ ] 27 – Techniques for Writing C Functions
    - [ ] 27.1 – Array Manipulation
    - [ ] 27.2 – String Manipulation
    - [ ] 27.3 – Storing State in C Functions
    - [ ] 27.3.1 – The Registry
    - [ ] 27.3.2 – References
    - [ ] 27.3.3 – Upvalues
- [ ] 28 – User-Defined Types in C
    - [ ] 28.1 – Userdata
    - [ ] 28.2 – Metatables
    - [ ] 28.3 – Object-Oriented Access
    - [ ] 28.4 – Array Access
    - [ ] 28.5 – Light Userdata
- [ ] 29 – Managing Resources
    - [ ] 29.1 – A Directory Iterator
    - [ ] 29.2 – An XML Parser
