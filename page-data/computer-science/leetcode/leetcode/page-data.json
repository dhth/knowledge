{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/computer-science/leetcode/leetcode","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Leetcode\"), mdx(\"h2\", null, \"Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/dhth/theScienceOfComputers/tree/master/dataStructuresAndAlgorithms/src/leetcode\"\n  }, \"dhth/theScienceOfComputers\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/labuladong/fucking-algorithm/tree/english\"\n  }, \"labuladong/fucking-algorithm\"))), mdx(\"h2\", null, \"Problems\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"141-linked-list-cycle\",\n    \"title\": \"141-linked-list-cycle\"\n  }, \"[[141-linked-list-cycle]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[19: Remove Nth Node From End of\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"19-remove-nth-node-from-end-of-list\",\n    \"title\": \"19-remove-nth-node-from-end-of-list\"\n  }, \"[[19-remove-nth-node-from-end-of-list]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[142: Linked List Cycle\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"142-linked-list-cycle-2\",\n    \"title\": \"142-linked-list-cycle-2\"\n  }, \"[[142-linked-list-cycle-2]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"143-reorder-list\",\n    \"title\": \"143-reorder-list\"\n  }, \"[[143-reorder-list]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[{"contextLine":"- [[141-linked-list-cycle]]","targetAnchor":null,"refWord":"141-linked-list-cycle","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"141: Linked List Cycle\"), mdx(\"h2\", null, \"Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare\"\n  }, \"Cycle Detection\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.geeksforgeeks.org/how-does-floyds-slow-and-fast-pointers-approach-work/\"\n  }, \"How does Floyd\\u2019s slow and fast pointers approach work?\"), \" \")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"ce8a6872-e05b-506c-95b2-aa25cc0fda50","fields":{"slug":"/computer-science/leetcode/141-linked-list-cycle","title":"141: Linked List Cycle"}}}},{"contextLine":"- [[19-remove-nth-node-from-end-of-list]]","targetAnchor":null,"refWord":"19-remove-nth-node-from-end-of-list","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"19: Remove Nth Node From End of List\"), mdx(\"p\", null, \"The requirement for one-pass algorithm is misleading. True one-pass for this\\nkind of problem is impossible (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/One-pass_algorithm\"\n  }, \"One-pass\\nAlgorithm\"), \").\"), mdx(\"p\", null, \"One way is to iterate through the list, find it's length, then iterate again,\\nand stop behind the node to be removed, and change references appropriately.\"), mdx(\"p\", null, \"Another approach would be to maintain two pointers to the list, both having \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \"\\ndistance between them. Continue iterating over the list, and updating pointers,\\nuntil the farther one reaches the end of the list. When this happens, the other\\npointer will be at the node to be removed.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"e20ed4a0-52a3-5c15-b6ac-91ab88a31bbf","fields":{"slug":"/computer-science/leetcode/19-remove-nth-node-from-end-of-list","title":"19: Remove Nth Node From End of List"}}}},{"contextLine":"- [[142-linked-list-cycle-2]]","targetAnchor":null,"refWord":"142-linked-list-cycle-2","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"142: Linked List Cycle 2\"), mdx(\"p\", null, \"Cleverly builds upon the problem of simply detecting if a loop exists or not.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/7e09ddd24b0a1f0fc1b6782a381230d4/142-linked-list-cycle-2.jpg\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"If we start two pointers at \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"head\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"meetingPoint\"), \", they'll meet after \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \"\\niterations, and that's the node where the cycle begins.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"850eef6c-8056-5973-9f5e-679079bf55f4","fields":{"slug":"/computer-science/leetcode/142-linked-list-cycle-2","title":"142: Linked List Cycle 2"}}}},{"contextLine":"- [[143-reorder-list]]","targetAnchor":null,"refWord":"143-reorder-list","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"143: Reorder List\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/fec63d47dfd9988cb274013c07a5d4d1/143-reorder-list.jpg\",\n    \"alt\": null\n  })));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"97e430f4-8ca5-5f48-9383-dc1c5c424897","fields":{"slug":"/computer-science/leetcode/143-reorder-list","title":"143: Reorder List"}}}}],"inboundReferences":[{"contextLine":"- [[leetcode]]","referrer":{"parent":{"id":"3edd5f36-641f-5998-9340-b966738bbdc7","fields":{"slug":"/computer-science/computer-science","title":"Computer Science"}}}}]},"fields":{"slug":"/computer-science/leetcode/leetcode","title":"Leetcode"}}},"pageContext":{"id":"c9f93050-6529-58eb-bc73-4d480c6fbe02","refWordMdxSlugDict":{"141-linked-list-cycle":"computer-science/leetcode/141-linked-list-cycle","19-remove-nth-node-from-end-of-list":"computer-science/leetcode/19-remove-nth-node-from-end-of-list","142-linked-list-cycle-2":"computer-science/leetcode/142-linked-list-cycle-2","143-reorder-list":"computer-science/leetcode/143-reorder-list"}}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}