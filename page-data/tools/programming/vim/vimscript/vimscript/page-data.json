{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/tools/programming/vim/vimscript/vimscript","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"VimScript\"), mdx(\"h2\", null, \"Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://learnvimscriptthehardway.stevelosh.com/\"\n  }, \"Learn Vimscript the Hard Way\"))), mdx(\"h2\", null, \"Modules\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"basic-vimscript\",\n    \"title\": \"basic-vimscript\"\n  }, \"[[basic-vimscript]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"operator-pending-mappings\",\n    \"title\": \"operator-pending-mappings\"\n  }, \"[[operator-pending-mappings]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"functions\",\n    \"title\": \"functions\"\n  }, \"[[functions]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"strings\",\n    \"title\": \"strings\"\n  }, \"[[strings]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"execute\",\n    \"title\": \"execute\"\n  }, \"[[execute]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[{"contextLine":"- [[basic-vimscript]]","targetAnchor":null,"refWord":"basic-vimscript","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Basic VimScript\"), mdx(\"h2\", null, \"Comparisons\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":set noignorecase\\n:if \\\"foo\\\" ==? \\\"FOO\\\"\\n:    echom \\\"first\\\"\\n:elseif \\\"foo\\\" ==? \\\"foo\\\"\\n:    echom \\\"second\\\"\\n:endif\"))), mdx(\"p\", null, \"Vim displays first because ==? is the \\\"case-insensitive no matter what the user has set\\\" comparison operator. Now run the following commands:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":set ignorecase\\n:if \\\"foo\\\" ==# \\\"FOO\\\"\\n:    echom \\\"one\\\"\\n:elseif \\\"foo\\\" ==# \\\"foo\\\"\\n:    echom \\\"two\\\"\\n:endif\"))), mdx(\"p\", null, \"Vim displays two because ==# is the \\\"case-sensitive no matter what the user has set\\\" comparison operator.\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"d94fec4a-e26d-50c2-8ae8-22ab5ae23e9a","fields":{"slug":"/tools/programming/vim/vimscript/basic-vimscript","title":"Basic VimScript"}}}},{"contextLine":"- [[operator-pending-mappings]]","targetAnchor":null,"refWord":"operator-pending-mappings","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Operator Pending Mappings\"), mdx(\"h2\", null, \"Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://learnvimscriptthehardway.stevelosh.com/chapters/15.html\"\n  }, \"Book\"))), mdx(\"h2\", null, \"Simple operator mapping\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"y\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c\"), \" are operators that wait for a movement command (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"w\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"i(\"), \", etc.).\\nVim lets you create new movements.\"), mdx(\"p\", null, \"Here's a sweet mapping to directly operator on the contents of the next braces.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":onoremap in( :<c-u>normal! f(vi(<cr>\"))), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"python\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-python\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token keyword\"\n  }, \"def\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token function\"\n  }, \"somefunc\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \"(\"), \"param1\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \",\"), \" param2\", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \")\"), mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token punctuation\"\n  }, \":\")))), mdx(\"p\", null, \"When the cursor is somewhere before the braces, running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cin()\"), \" will clear out\\nthe contents of the braces.\"), mdx(\"p\", null, \"Structural breakdown of the mapping:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Component\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"in(\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"new movement\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"<c-u>\")), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  })), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"normal!\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"execute normal mode commands\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"f(\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"find next \", mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"(\"))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"vi(\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"visual selection\")))), mdx(\"h2\", null, \"Operator mapping using \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"execute\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"normal!\"), \" doesn't recognize \\\"special characters\\\" like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<cr>\"), \". There are a number\\nof ways around this, but the easiest to use and read is execute.\"), mdx(\"p\", null, \"The execute command is used to evaluate a string as if it were a Vimscript\\ncommand.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":onoremap ih :<c-u>execute \\\"normal! ?^==\\\\\\\\+$\\\\r:nohlsearch\\\\rkvg_\\\"<cr>\"))), mdx(\"p\", null, \"When \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \" looks at the string you tell it to run, it will substitute any\\nspecial characters it finds before running it. In this case, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\r\"), \" is an escape\\nsequence that means \\\"carriage return\\\". The double backslash is also an escape\\nsequence that puts a literal backslash in the string.\"), mdx(\"p\", null, \"So, the above command can be seen as:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":normal! ?^==\\\\+$<cr>:nohlsearch<cr>kvg_\\n                ^^^^           ^^^^\\n                 ||             ||\\nThese are ACTUAL carriage returns, NOT the four characters\\n\\\"left angle bracket\\\", \\\"c\\\", \\\"r\\\", and \\\"right angle bracket\\\".\"))), mdx(\"p\", null, \"which can be further broken down as:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"?^==\\\\+$     \\\" search backwards for a line containing == or more\\n:nohlsearch \\\" no visual highlight\\nkvg_        \\\" up one line, highlight to last non-blank character\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"b346b32a-ed92-5539-b29e-867812480f72","fields":{"slug":"/tools/programming/vim/vimscript/operator-pending-mappings","title":"Operator Pending Mappings"}}}},{"contextLine":"- [[functions]]","targetAnchor":null,"refWord":"functions","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Functions\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":function DisplayName(name)\\n:  echom \\\"Hello!  My name is:\\\"\\n:  echom a:name\\n:endfunction\"))), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a:\"), \" represents that the variable is in the argument scope.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":function Varg2(foo, ...)\\n:  echom a:foo\\n:  echom a:0\\n:  echom a:1\\n:  echo a:000\\n:endfunction\\n\\n:call Varg2(\\\"a\\\", \\\"b\\\", \\\"c\\\")\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a:0\"), \": number of extra arguments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a:1\"), \": first extra argument\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a:000\"), \": list of extra arguments\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"629ea08a-cf76-575a-8e35-380e314246f9","fields":{"slug":"/tools/programming/vim/vimscript/functions","title":"Functions"}}}},{"contextLine":"- [[strings]]","targetAnchor":null,"refWord":"strings","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Strings\"), mdx(\"h2\", null, \"Concatenate\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":echom \\\"Hello, \\\" . \\\"world\\\"\"))), mdx(\"h2\", null, \"Special Characters\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":echom \\\"foo\\\\nbar\\\"\"))), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"^@\"), \" is Vim's way of saying \\\"newline character\\\".\"), mdx(\"h2\", null, \"Literal Strings\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":echom '\\\\n\\\\\\\\'\"))), mdx(\"p\", null, \"Vim displays \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\n\\\\\\\\\"), \".\"), mdx(\"h2\", null, \"String Functions\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":echom len(\\\"foo\\\")\\n\\n:echo split(\\\"one,two,three\\\", \\\",\\\")\\n\\n:echo join(split(\\\"foo bar\\\"), \\\";\\\")\\n\\n:echom tolower(\\\"Foo\\\")\\n:echom toupper(\\\"Foo\\\")\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"b3fd04d0-a866-580b-bc1a-c89be3102712","fields":{"slug":"/tools/programming/vim/vimscript/strings","title":"Strings"}}}},{"contextLine":"- [[execute]]","targetAnchor":null,"refWord":"execute","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Execute\"), mdx(\"h2\", null, \"Usage\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \" in conjuction with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"normal!\"), \" let's us escape special characters.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":execute \\\"normal! mqA;\\\\<esc>`q\\\"\"))), mdx(\"p\", null, \"Breakdown:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \":execute \\\"normal! ...\\\"\"), \": run the sequence of commands as if they were\\nentered in normal mode, ignoring all mappings, and replacing string escape\\nsequences with their results.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mq\"), \": store the current location in mark \\\"q\\\".  \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"A\"), \": move to the end of the\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"current line and enter insert mode after the last\\ncharacter.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \";\"), \": we're now in insert mode, so just put a literal semicolon in the file.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\\\<esc>\"), \": this is a string escape sequence which resolves to a press of the\\nescape key, which takes us out of insert mode.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"`\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"q\"), \": return to the exact location of mark \\\"q\\\".\")), mdx(\"h2\", null, \"Regex in commands\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":execute \\\"normal! gg\\\" . '/for .\\\\+ in .\\\\+:' . \\\"\\\\<cr>\\\"\"))), mdx(\"p\", null, \"The middle component will be treated as a literal string, so we don't need to\\nescape \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".\\\\+\"), \".\"), mdx(\"h2\", null, \"Very Magic\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":execute \\\"normal! gg\\\" . '/\\\\vfor .+ in .+:' . \\\"\\\\<cr>\\\"\"))), mdx(\"p\", null, \"This tells Vim to use its \\\"very magic\\\" regex parsing mode, which is pretty much\\nthe same as you're used to in any other programming language.\"), mdx(\"h2\", null, \"Escaping characters\"), mdx(\"p\", null, \"If the cursor is on the word \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"don't\"), \":\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":echom expand(\\\"<cWORD>\\\")\\n\\\" will output don't\"))), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \":echom shellescape(expand(\\\"<cWORD>\\\"))\\n\\\" will output 'don'\\\\''t'\"))), mdx(\"p\", null, \"More \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://learnvimscriptthehardway.stevelosh.com/chapters/32.html\"\n  }, \"\\nhere\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"957cd229-fd2d-5c78-83be-84027ccd8863","fields":{"slug":"/tools/programming/vim/vimscript/execute","title":"Execute"}}}}],"inboundReferences":[{"contextLine":"- [[vimscript]]","referrer":{"parent":{"id":"1608dd64-4c51-5355-944b-9b0edd028597","fields":{"slug":"/tools/programming/vim/vim","title":"Vim"}}}},{"contextLine":"[[vimscript]] regex to extract it would be:","referrer":{"parent":{"id":"28e03478-0d03-581c-85cd-88a5ef03a61f","fields":{"slug":"/programming/regex/get-string-between-brackets","title":"Get string between brackets"}}}}]},"fields":{"slug":"/tools/programming/vim/vimscript/vimscript","title":"VimScript"}}},"pageContext":{"id":"2e699bf5-7d8e-55a2-8b74-60d392d5e9e1","refWordMdxSlugDict":{"basic-vimscript":"tools/programming/vim/vimscript/basic-vimscript","operator-pending-mappings":"tools/programming/vim/vimscript/operator-pending-mappings","functions":"tools/programming/vim/vimscript/functions","strings":"tools/programming/vim/vimscript/strings","execute":"tools/programming/vim/vimscript/execute"}}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}