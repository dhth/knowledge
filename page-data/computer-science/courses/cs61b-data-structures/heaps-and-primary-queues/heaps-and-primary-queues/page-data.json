{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/computer-science/courses/cs61b-data-structures/heaps-and-primary-queues/heaps-and-primary-queues","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Heaps and Primary Queues\"), mdx(\"h2\", null, \"Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/playlist?list=PL8FaHk7qbOD50LnOXTSpYgnVJQTIVFsmI\"\n  }, \"Lectures\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.google.com/presentation/d/1XgdL3QTKYRAVa14qQznoVORqrPug5tNdmiDmbqM5FlE/edit?usp=sharing\"\n  }, \"Slides\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://sp19.datastructur.es/materials/lectures/lec20/lec20\"\n  }, \"Guide\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.geeksforgeeks.org/heap-data-structure/\"\n  }, \"GeeksforGeeks\"))), mdx(\"h2\", null, \"Motivation\"), mdx(\"p\", null, \"Till now we've seen data structures that let us search individual data items\\nbased on some kind of identifier (eg. a key, or a label). Let us move on to a\\nuse case where we'd need to keep track of the smallest item (or largest, or the\\n\\\"best\\\" item, based on a specific metric) amongst a bunch of items. Primary\\nQueues solve this problem.\"), mdx(\"p\", null, \"Let's consider a scenario to explore this use case. Suppose we're monitoring a\\nstream of tweets sent by a pool of users, and, at the end of each day, we need\\nto create a report of the most \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"M\"), \"(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"M\"), \" is a number) vicious tweets of that day.\\nA naive approach to do this would be to create a list of tweets sent in a day;\\nthen sort the list in decreasing order of viciousness (using some sort of\\ncomparator), and finally return the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"M\"), \" tweets.\"), mdx(\"p\", null, \"This approach will work; however, it potentially uses a large amount of memory\\n(of the order \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(N)\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"N\"), \" is the number of tweets from a day). The goal\\nfor this exercise \\u2014 and a motivation for priority queues \\u2014 is to do the same\\nusing only \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(M)\"), \" memory. Let's see two approaches to solve this problem \\u2014 the\\nfirst being the naive approach described above; the second uses a primary queue\\n\\u2014 in pseudocode.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"// Naive approach\\n- initialize allMessages as a list\\n- start streaming tweets at start of day\\n- on new tweet arrival\\n\\t- allMessages.add(newTweet)\\n- at end of day\\n\\tsort allTweets\\n- return allTweets.sublist(0,M)\\n\\n// Using a primary queue\\n- intialize tweetsPQ as a primary queue (that tracks\\nleast vicious tweet)\\n- start streaming tweets at start of day\\n- on new tweet arrival\\n\\t- tweetsPQ.add(newTweet)\\n\\t- if tweetsPQ.size() > M: tweetsPQ.removeSmallest()\\n- at end of day\\n\\t- initialize mostViciousTweets as a list\\n\\t- for (i=0; i<tweetsPQ.size(); i++): mostViciousTweets.add(tweetsPQ.removeSmallest())\\n- return mostViciousTweets\"))), mdx(\"p\", null, \"Using the second technique, we won't have to store all of the streaming tweets\\nin memory, we'd only be storing (upto) \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"M\"), \" most vicious tweets at any point in\\ntime. Pretty cool! Also, as seen above, the key operations of a priority queue\\nare:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pq.add()\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pq.removeSmallest()\"))), mdx(\"p\", null, \"A few more operations that would make the priority queue data structure more\\nuseful:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pq.getSmallest()\"), \" (getting the value of the smallest item, without removing\\nit)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pq.size()\"))), mdx(\"h2\", null, \"Underlying data structure\"), mdx(\"p\", null, \"Let's consider options for the underlying data structure for implementing a\\npriority queue. We could do it by using an ordered array or a bushy Binary\\nSearch Tree. Let's go through the worst case runtimes for both of them:\"), mdx(\"h2\", null, \"Ordered Array\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add\"), \" will take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\u0398(N)\"), \" time, as the array will have to be ordered every time\\na new item is added.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"getSmallest\"), \" will take constant time, as it will always be the first element\\nin the array.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"removeSmallest\"), \" will take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\u0398(N)\"), \" time in the worst case, as the array will\\nhave to be resized.\")), mdx(\"h2\", null, \"Bushy BST\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" operation corresponds to a normal insertion in a bushy BST. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getSmallest\"), \"\\nand \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"removeSmallest\"), \" correspond to searching the tree for the smallest item\\n(traverse left till a leaf is reached). All three will take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(log N)\"), \" time in the\\nworst case. But, dealing with duplicates in a BST is tricky, and a priority\\nqueue can have duplicates. This makes a BST a bad contender for this use case.\"), mdx(\"p\", null, \"The worst case runtimes for these two data structures can be summarized as\\nfollows.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Operation\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Ordered Array\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Bushy BST\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"add\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"getSmallest\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(1)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"removeSmallest\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")))), mdx(\"p\", null, \"We need a specialized data structure that caters to the very specific needs of a\\npriority queue.\"), mdx(\"h2\", null, \"Heap\"), mdx(\"p\", null, \"Heaps are a great way to implement a priority queue. Specifically, let's take a\\nlook at a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"binary min-heap\"), \", a data structure that keeps track of the minimum\\nelement amongst the items added to it. A binary min-heap is a variant of a\\nbinary tree that has two additional properties:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Every node is less than or equal to both of its children (\", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Min-heap\\nproperty)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"complete\"), \" binary tree, ie, it is missing items only at the bottom\\nlevel (if any), and all nodes are as far left as possible.\")), mdx(\"p\", null, \"The following three are valid binary min-heaps:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/b7b67597b06ad83e750d579e50258e1e/1.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"On the other hand, the following four are not binary min-heaps, due to the\\nreasons mentioned below each tree.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/9d0b1ddb6d097a22b9d6c28cc048290f/2.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/c84379528c225cf78c4504b3d1fb763e/3.png\",\n    \"alt\": null\n  })), mdx(\"h3\", null, \"getSmallest()\"), mdx(\"p\", null, \"As a consequence of the min-heap property, getting the value of the smallest\\nitem in the heap is very easy: it's always the value of the root node. As such,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getSmallest\"), \" has a runtime of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(1)\"), \".\"), mdx(\"h3\", null, \"add()\"), mdx(\"p\", null, \"Adding an item to a heap is slightly more complicated; the complication arises\\nfrom the fact that the resultant structure (after insertion) must be a min-heap\\nitself. The following presentation describes the working of this operation.\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vQyr2OtkVJpvbv1bDlmGaVi36heVBVvMnmAchIXm7qwMHFed1t59uKSD4C-s7kI-ce1W7EZxe5G_j2R/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"h3\", null, \"removeSmallest()\"), mdx(\"p\", null, \"Removing an item means changing the value of the root node in the tree. Since\\nthe resultant tree has to be a min-heap, we need to replace it with an\\nappropriate element from the heap itself. The following presentation describes this\\noperation.\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vTdtjjuvPYCNUTuHYWpPKK8kvSps5RVU0FXHg3yPNxWWdfpfmyxGadJqWeiSMI8IBVmLiBVWDXhXeX7/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"h2\", null, \"Implementation\"), mdx(\"p\", null, \"Next, let's see how all of this is implemented. Instead of implementing a tree\\nbased data structure in the way we've seen before (using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"left\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"right\"), \"\\nreferences), we'll implement it using an array. The reason for doing so is that\\narrays lend themselves very nicely to the narrow set of operations of a min-heap\\ntree, as we'll see soon.\"), mdx(\"p\", null, \"The nodes of the tree will be ordered by level, starting at root, and, from left\\nto right, as seen in the following image. We keep the first element in the array\\nempty to make the math (as we'll see soon) a bit simpler.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/5d2a4b9d576ebddd7a1b83636d8ab01b/4.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Let's see how this array representation makes our lives simpler.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If we maintain a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"size\"), \" variable, adding an item \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"newItem\"), \" to the tree is\\nsimply assigning \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"array[size+1] = newItem\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can find the parent of the node at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"n\"), \" at the index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"floor(n/2)\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The left child of a node at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"n\"), \" is at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"2*n\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The right child of a node at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"n\"), \" is at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"2*n + 1\"), \".\")), mdx(\"h3\", null, \"getSmallest()\"), mdx(\"p\", null, \"As mentioned before getting the value of the smallest item in the heap is as\\nsimple as returning \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array[1]\"), \".\"), mdx(\"h3\", null, \"add()\"), mdx(\"p\", null, \"We start by adding the new item to the array. We then make the item this item\\n\\\"swim up\\\" to an appropriate position in the tree. The following video describes\\nthe implemention in more detail.\"), mdx(\"p\", null, \"[VID]\"), mdx(\"h3\", null, \"removeSmallest()\"), mdx(\"p\", null, \"We start by copying the item at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" for further retrieval. The item at the\\nlast index is removed and it's contents are placed at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \". We then make\\nthis item \\\"swim down\\\" the tree to an appropriate location. The following video\\ndescribes the implemention in more detail.\"), mdx(\"p\", null, \"[VID]\"), mdx(\"h2\", null, \"Runtime\"), mdx(\"p\", null, \"Let's summarize the worst case runtimes of the operations of a min-heap and\\ncompare them to those of an ordered array and a bushy BST. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"removeSmallest\"), \" will take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(logN)\"), \" in the worst case (when we need to \\\"swim\\nup\\\" and \\\"swim down\\\" the entire depth of the tree). This runtime is actually\\namortized since the underlying array will need to be resized occasionally.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getSmallest\"), \" will take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(1)\"), \" time.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Operation\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Ordered Array\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Bushy BST\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Heap\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"add\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"getSmallest\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(1)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(1)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"removeSmallest\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[],"inboundReferences":[{"contextLine":"- [[heaps-and-primary-queues]]","referrer":{"parent":{"id":"7a2ed90b-bf85-5596-8620-2b3708fa9e83","fields":{"slug":"/computer-science/courses/cs61b-data-structures/cs61b-data-structures","title":"CS61B Data Structures"}}}}]},"fields":{"slug":"/computer-science/courses/cs61b-data-structures/heaps-and-primary-queues/heaps-and-primary-queues","title":"Heaps and Primary Queues"}}},"pageContext":{"id":"dffb28b9-19fe-5bc0-83d2-26cc7eaeb3e9","refWordMdxSlugDict":{}}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}