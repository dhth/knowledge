{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/computer-science/leetcode/19-remove-nth-node-from-end-of-list","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"19: Remove Nth Node From End of List\"), mdx(\"p\", null, \"The requirement for one-pass algorithm is misleading. True one-pass for this\\nkind of problem is impossible (\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/One-pass_algorithm\"\n  }, \"One-pass\\nAlgorithm\"), \").\"), mdx(\"p\", null, \"One way is to iterate through the list, find it's length, then iterate again,\\nand stop behind the node to be removed, and change references appropriately.\"), mdx(\"p\", null, \"Another approach would be to maintain two pointers to the list, both having \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \"\\ndistance between them. Continue iterating over the list, and updating pointers,\\nuntil the farther one reaches the end of the list. When this happens, the other\\npointer will be at the node to be removed.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[],"inboundReferences":[{"contextLine":"- [[19-remove-nth-node-from-end-of-list]]","referrer":{"parent":{"id":"c9f93050-6529-58eb-bc73-4d480c6fbe02","fields":{"slug":"/computer-science/leetcode/leetcode","title":"Leetcode"}}}}]},"fields":{"slug":"/computer-science/leetcode/19-remove-nth-node-from-end-of-list","title":"19: Remove Nth Node From End of List"}}},"pageContext":{"id":"e20ed4a0-52a3-5c15-b6ac-91ab88a31bbf","refWordMdxSlugDict":{}}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}