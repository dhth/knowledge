A Common-Sense Guide to Data Structures and Algorithms
===

Resources
---

- [A Common-Sense Guide to Data Structures and Algorithms, Second Edition: Level Up Your Core Programming Skills by Jay Wengrow][1]

<!-- Links -->
[1]: https://pragprog.com/titles/jwdsal2/a-common-sense-guide-to-data-structures-and-algorithms-second-edition/

<!-- Links end -->


Chapter Checklist
---

- [x] 1. Why Data Structures Matter
    - [x] The Array: The Foundational Data Structure
    - [x] Reading
    - [x] Searching
    - [x] Insertion
    - [x] Deletion
    - [x] Sets: How a Single Rule Can Affect Efficiency
    - [x] Wrapping Up
- [x] 2. Why Algorithms Matter
    - [x] Ordered Arrays
    - [x] Searching an Ordered Array
    - [x] Binary Search
    - [x] Binary Search vs. Linear Search
    - [x] Wrapping Up
- [x] 3. Oh Yes! Big O Notation
    - [x] Big O: Count the Steps
    - [x] Constant Time vs. Linear Time
    - [x] Same Algorithm, Different Scenarios
    - [x] An Algorithm of the Third Kind
    - [x] Logarithms
    - [x] O(log N) Explained
    - [x] Practical Examples
    - [x] Wrapping Up
- [x] 4. Speeding Up Your Code with Big O
    - [x] Bubble Sort
    - [x] Bubble Sort in Action
    - [x] Bubble Sort Implemented
    - [x] The Efficiency of Bubble Sort
    - [x] A Quadratic Problem
    - [x] A Linear Solution
    - [x] Wrapping Up
- [x] 5. Optimizing Code with and Without Big O
    - [x] Selection Sort
    - [x] Selection Sort in Action
    - [x] Selection Sort Implemented
    - [x] The Efficiency of Selection Sort
    - [x] Ignoring Constants
    - [x] The Role of Big O
    - [x] A Practical Example
    - [x] Wrapping Up
- [ ] 6. Optimizing for Optimistic Scenarios
    - [ ] Insertion Sort
    - [ ] Insertion Sort in Action
    - [ ] Insertion Sort Implemented
    - [ ] The Efficiency of Insertion Sort
    - [ ] The Average Case
    - [ ] A Practical Example
    - [ ] Wrapping Up
- [ ] 7. Blazing Fast Lookup with Hash Tables
    - [ ] Enter the Hash Table
    - [ ] Hashing with Hash Functions
    - [ ] Building a Thesaurus for Fun and Profit, but Mainly Profit
    - [ ] Dealing with Collisions
    - [ ] The Great Balancing Act
    - [ ] Practical Examples
    - [ ] Wrapping Up
- [ ] 8. Crafting Elegant Code with Stacks and Queues
    - [ ] Stacks
    - [ ] Stacks in Action
    - [ ] Queues
    - [ ] Queues in Action
    - [ ] Wrapping Up
- [ ] 9. Recursively Recurse with Recursion
    - [ ] Recurse Instead of Loop
    - [ ] The Base Case
    - [ ] Reading Recursive Code
    - [ ] Recursion in the Eyes of the Computer
    - [ ] Recursion in Action
    - [ ] Wrapping Up
- [ ] 10. Recursive Algorithms for Speed
    - [ ] Partitioning
    - [ ] Quicksort
    - [ ] The Efficiency of Quicksort
    - [ ] Worst-Case Scenario
    - [ ] Quickselect
    - [ ] Wrapping Up
- [ ] 11. Node-Based Data Structures
    - [ ] Linked Lists
    - [ ] Implementing a Linked List
    - [ ] Reading
    - [ ] Searching
    - [ ] Insertion
    - [ ] Deletion
    - [ ] Linked Lists in Action
    - [ ] Doubly Linked Lists
    - [ ] Wrapping Up
- [ ] 12. Speeding Up All the Things with Binary Trees
    - [ ] Binary Trees
    - [ ] Searching
    - [ ] Insertion
    - [ ] Deletion
    - [ ] Binary Trees in Action
    - [ ] Wrapping Up
- [ ] 13. Connecting Everything with Graphs
    - [ ] Graphs
    - [ ] Breadth-First Search
    - [ ] Graph Databases
    - [ ] Weighted Graphs
    - [ ] Dijkstraâ€™s Algorithm
    - [ ] Wrapping Up
- [ ] 14. Dealing with Space Constraints
    - [ ] Big O Notation as Applied to Space Complexity
    - [ ] Trade-Offs Between Time and Space
    - [ ] Parting Thoughts
