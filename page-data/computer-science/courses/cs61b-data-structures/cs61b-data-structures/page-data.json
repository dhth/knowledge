{"componentChunkName":"component---node-modules-gatsby-theme-kb-src-templates-topic-js","path":"/computer-science/courses/cs61b-data-structures/cs61b-data-structures","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"CS61B Data Structures\"), mdx(\"h2\", null, \"Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://sp19.datastructur.es/\"\n  }, \"Course Page\"))), mdx(\"h2\", null, \"Modules\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"asymptotics/asymptotics\",\n    \"title\": \"asymptotics\"\n  }, \"[[asymptotics]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"b-trees/b-trees\",\n    \"title\": \"b-trees\"\n  }, \"[[b-trees]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"heaps-and-primary-queues/heaps-and-primary-queues\",\n    \"title\": \"heaps-and-primary-queues\"\n  }, \"[[heaps-and-primary-queues]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"range-searching-and-multi-dimensional-data/range-searching-and-multi-dimensional-data\",\n    \"title\": \"range-searching-and-multi-dimensional-data\"\n  }, \"[[range-searching-and-multi-dimensional-data]]\"), \"\")), mdx(\"h2\", null, \"Lecture Checklist\"), mdx(\"ul\", {\n    \"className\": \"contains-task-list\"\n  }, mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"1: Intro, Hello World Java\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"2: Defining and Using Classes\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"3: References, Recursion, and Lists\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"4: SLLists, Nested Classes, Sentinel Nodes\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"5: DLLists, Arrays\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"6: ALists, Resizing, vs. SLists\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"7: Testing\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"8: Inheritance, Implements\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"9: Extends, Casting, Higher Order Functions\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"10: Subtype Polymorphism vs. HoFs\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"11: Exceptions, Iterators, Object Methods\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"12: Coding in the Real World, Review\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"13: Asymptotics I\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"14: Disjoint Sets\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"15: Asymptotics II\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"16: ADTs, Sets, Maps, BSTs\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"17: B-Trees (2-3, 2-3-4 Trees)\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"18: Red Black Trees\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"19: Hashing\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  }), \" \", \"20: Heaps and PQs\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"21: Prefix Operations and Tries\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"22: Range Searching and Multi-Dimensional Data\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"23: Tree and Graph Traversals\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"24: Graph Traversals and Implementations\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"25: Shortest Paths\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"26: Minimum Spanning Trees\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"27: Reductions and Decomposition\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"29: Basic Sorts\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"30: Quick Sort\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"31: Software Engineering I\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"32: More Quick Sort, Sorting Summary\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"33: Sorting and Algorithmic Bounds\"), mdx(\"li\", {\n    parentName: \"ul\",\n    \"className\": \"task-list-item\"\n  }, mdx(\"input\", {\n    parentName: \"li\",\n    \"type\": \"checkbox\",\n    \"checked\": false,\n    \"disabled\": true\n  }), \" \", \"34: Software Engineering II\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"","private":false},"outboundReferences":[{"contextLine":"- [[asymptotics]]","targetAnchor":null,"refWord":"asymptotics","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Asymptotics\"), mdx(\"h2\", null, \"Big Theta\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/edf4b19199193d3d3fd0880adc19e015/big-theta.png\",\n    \"alt\": \"big-theta\"\n  })), mdx(\"p\", null, \"!!! note \\\"Big Theta -> order of growth\\\"\"), mdx(\"h2\", null, \"Big O\"), mdx(\"p\", null, \"!!! note \\\"Big Theta can be thought of something like \\\"equal to\\\", Big O can be thought of as \\\"less than or equal to\\\".\\\"\"), mdx(\"p\", null, \"For formal definition, we just remove the left hand side from Big Theta.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/410072ce299a13c15fd2b94a61f3291d/big-o.png\",\n    \"alt\": null\n  })), mdx(\"h2\", null, \"Increasing Order\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/4e5a5646273649518f58e6f849920f9a/inc-order-1.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/6478fc99802be39def6b36f5a0bba461/inc-order-2.png\",\n    \"alt\": null\n  })));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"1f6ed1a0-2ce7-58de-95c3-9756d5fe6801","fields":{"slug":"/computer-science/courses/cs61b-data-structures/asymptotics/asymptotics","title":"Asymptotics"}}}},{"contextLine":"- [[b-trees]]","targetAnchor":null,"refWord":"b-trees","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"B Trees\"), mdx(\"p\", null, \"Related to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../../wiki/01-binary-search-trees\",\n    \"title\": \"01-binary-search-trees\"\n  }, \"[[01-binary-search-trees]]\"), \".\"), mdx(\"h2\", null, \"Asymptotics for tree height\"), mdx(\"p\", null, \"Which statement gives you more information about a hotel?\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"A) The most expensive room in the hotel is $639 per night.\\nB) Every room in the hotel is less than or equal to $639 per night.\"))), mdx(\"p\", null, \"The answer is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \", since we know for sure that there is atleast one room in the\\nhotel that costs $639, whereas there is no guarantee of that in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \". Moreover, a\\nlarge number of hotels, (or motels) would fulfill the statement in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"B\"), \" (ie, have\\nrooms that cost a 100 bucks, but would still fulfill the statement).\"), mdx(\"p\", null, \"In the same vein, the one of the following statements about tree height is more\\ninformative:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"A) Worst case BST height is \\u0398(N).\\nB) BST height is O(N).\"))), mdx(\"p\", null, \"In this case, it's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \".\"), mdx(\"p\", null, \"Which leads to the question, why is Big O useful? It's because of the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Allows us to make simple blanket statements, e.g. can just say \\u201Cbinary search\\nis O(log N)\\u201D instead of \\u201Cbinary search is \\u0398(log N) in the worst case\\u201D.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sometimes don\\u2019t know the exact runtime, so use O to give an upper bound.\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"4f844ede-cf11-55a6-8006-410dc8749f8f","fields":{"slug":"/computer-science/courses/cs61b-data-structures/b-trees/b-trees","title":"B Trees"}}}},{"contextLine":"- [[heaps-and-primary-queues]]","targetAnchor":null,"refWord":"heaps-and-primary-queues","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Heaps and Primary Queues\"), mdx(\"h2\", null, \"Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/playlist?list=PL8FaHk7qbOD50LnOXTSpYgnVJQTIVFsmI\"\n  }, \"Lectures\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.google.com/presentation/d/1XgdL3QTKYRAVa14qQznoVORqrPug5tNdmiDmbqM5FlE/edit?usp=sharing\"\n  }, \"Slides\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://sp19.datastructur.es/materials/lectures/lec20/lec20\"\n  }, \"Guide\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.geeksforgeeks.org/heap-data-structure/\"\n  }, \"GeeksforGeeks\"))), mdx(\"h2\", null, \"Motivation\"), mdx(\"p\", null, \"Till now we've seen data structures that let us search individual data items\\nbased on some kind of identifier (eg. a key, or a label). Let us move on to a\\nuse case where we'd need to keep track of the smallest item (or largest, or the\\n\\\"best\\\" item, based on a specific metric) amongst a bunch of items. Primary\\nQueues solve this problem.\"), mdx(\"p\", null, \"Let's consider a scenario to explore this use case. Suppose we're monitoring a\\nstream of tweets sent by a pool of users, and, at the end of each day, we need\\nto create a report of the most \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"M\"), \"(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"M\"), \" is a number) vicious tweets of that day.\\nA naive approach to do this would be to create a list of tweets sent in a day;\\nthen sort the list in decreasing order of viciousness (using some sort of\\ncomparator), and finally return the first \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"M\"), \" tweets.\"), mdx(\"p\", null, \"This approach will work; however, it potentially uses a large amount of memory\\n(of the order \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(N)\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"N\"), \" is the number of tweets from a day). The goal\\nfor this exercise \\u2014 and a motivation for priority queues \\u2014 is to do the same\\nusing only \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(M)\"), \" memory. Let's see two approaches to solve this problem \\u2014 the\\nfirst being the naive approach described above; the second uses a primary queue\\n\\u2014 in pseudocode.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"// Naive approach\\n- initialize allMessages as a list\\n- start streaming tweets at start of day\\n- on new tweet arrival\\n\\t- allMessages.add(newTweet)\\n- at end of day\\n\\tsort allTweets\\n- return allTweets.sublist(0,M)\\n\\n// Using a primary queue\\n- intialize tweetsPQ as a primary queue (that tracks\\nleast vicious tweet)\\n- start streaming tweets at start of day\\n- on new tweet arrival\\n\\t- tweetsPQ.add(newTweet)\\n\\t- if tweetsPQ.size() > M: tweetsPQ.removeSmallest()\\n- at end of day\\n\\t- initialize mostViciousTweets as a list\\n\\t- for (i=0; i<tweetsPQ.size(); i++): mostViciousTweets.add(tweetsPQ.removeSmallest())\\n- return mostViciousTweets\"))), mdx(\"p\", null, \"Using the second technique, we won't have to store all of the streaming tweets\\nin memory, we'd only be storing (upto) \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"M\"), \" most vicious tweets at any point in\\ntime. Pretty cool! Also, as seen above, the key operations of a priority queue\\nare:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pq.add()\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pq.removeSmallest()\"))), mdx(\"p\", null, \"A few more operations that would make the priority queue data structure more\\nuseful:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pq.getSmallest()\"), \" (getting the value of the smallest item, without removing\\nit)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pq.size()\"))), mdx(\"h2\", null, \"Underlying data structure\"), mdx(\"p\", null, \"Let's consider options for the underlying data structure for implementing a\\npriority queue. We could do it by using an ordered array or a bushy Binary\\nSearch Tree. Let's go through the worst case runtimes for both of them:\"), mdx(\"h2\", null, \"Ordered Array\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add\"), \" will take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\u0398(N)\"), \" time, as the array will have to be ordered every time\\na new item is added.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"getSmallest\"), \" will take constant time, as it will always be the first element\\nin the array.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"removeSmallest\"), \" will take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"\\u0398(N)\"), \" time in the worst case, as the array will\\nhave to be resized.\")), mdx(\"h2\", null, \"Bushy BST\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" operation corresponds to a normal insertion in a bushy BST. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getSmallest\"), \"\\nand \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"removeSmallest\"), \" correspond to searching the tree for the smallest item\\n(traverse left till a leaf is reached). All three will take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(log N)\"), \" time in the\\nworst case. But, dealing with duplicates in a BST is tricky, and a priority\\nqueue can have duplicates. This makes a BST a bad contender for this use case.\"), mdx(\"p\", null, \"The worst case runtimes for these two data structures can be summarized as\\nfollows.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Operation\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Ordered Array\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Bushy BST\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"add\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"getSmallest\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(1)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"removeSmallest\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")))), mdx(\"p\", null, \"We need a specialized data structure that caters to the very specific needs of a\\npriority queue.\"), mdx(\"h2\", null, \"Heap\"), mdx(\"p\", null, \"Heaps are a great way to implement a priority queue. Specifically, let's take a\\nlook at a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"binary min-heap\"), \", a data structure that keeps track of the minimum\\nelement amongst the items added to it. A binary min-heap is a variant of a\\nbinary tree that has two additional properties:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Every node is less than or equal to both of its children (\", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Min-heap\\nproperty)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It is a \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"complete\"), \" binary tree, ie, it is missing items only at the bottom\\nlevel (if any), and all nodes are as far left as possible.\")), mdx(\"p\", null, \"The following three are valid binary min-heaps:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/b7b67597b06ad83e750d579e50258e1e/1.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"On the other hand, the following four are not binary min-heaps, due to the\\nreasons mentioned below each tree.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/9d0b1ddb6d097a22b9d6c28cc048290f/2.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/c84379528c225cf78c4504b3d1fb763e/3.png\",\n    \"alt\": null\n  })), mdx(\"h3\", null, \"getSmallest()\"), mdx(\"p\", null, \"As a consequence of the min-heap property, getting the value of the smallest\\nitem in the heap is very easy: it's always the value of the root node. As such,\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getSmallest\"), \" has a runtime of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(1)\"), \".\"), mdx(\"h3\", null, \"add()\"), mdx(\"p\", null, \"Adding an item to a heap is slightly more complicated; the complication arises\\nfrom the fact that the resultant structure (after insertion) must be a min-heap\\nitself. The following presentation describes the working of this operation.\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vQyr2OtkVJpvbv1bDlmGaVi36heVBVvMnmAchIXm7qwMHFed1t59uKSD4C-s7kI-ce1W7EZxe5G_j2R/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"h3\", null, \"removeSmallest()\"), mdx(\"p\", null, \"Removing an item means changing the value of the root node in the tree. Since\\nthe resultant tree has to be a min-heap, we need to replace it with an\\nappropriate element from the heap itself. The following presentation describes this\\noperation.\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vTdtjjuvPYCNUTuHYWpPKK8kvSps5RVU0FXHg3yPNxWWdfpfmyxGadJqWeiSMI8IBVmLiBVWDXhXeX7/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"h2\", null, \"Implementation\"), mdx(\"p\", null, \"Next, let's see how all of this is implemented. Instead of implementing a tree\\nbased data structure in the way we've seen before (using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"left\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"right\"), \"\\nreferences), we'll implement it using an array. The reason for doing so is that\\narrays lend themselves very nicely to the narrow set of operations of a min-heap\\ntree, as we'll see soon.\"), mdx(\"p\", null, \"The nodes of the tree will be ordered by level, starting at root, and, from left\\nto right, as seen in the following image. We keep the first element in the array\\nempty to make the math (as we'll see soon) a bit simpler.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/5d2a4b9d576ebddd7a1b83636d8ab01b/4.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Let's see how this array representation makes our lives simpler.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If we maintain a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"size\"), \" variable, adding an item \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"newItem\"), \" to the tree is\\nsimply assigning \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"array[size+1] = newItem\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can find the parent of the node at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"n\"), \" at the index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"floor(n/2)\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The left child of a node at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"n\"), \" is at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"2*n\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The right child of a node at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"n\"), \" is at index \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"2*n + 1\"), \".\")), mdx(\"h3\", null, \"getSmallest()\"), mdx(\"p\", null, \"As mentioned before getting the value of the smallest item in the heap is as\\nsimple as returning \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"array[1]\"), \".\"), mdx(\"h3\", null, \"add()\"), mdx(\"p\", null, \"We start by adding the new item to the array. We then make the item this item\\n\\\"swim up\\\" to an appropriate position in the tree. The following video describes\\nthe implemention in more detail.\"), mdx(\"p\", null, \"[VID]\"), mdx(\"h3\", null, \"removeSmallest()\"), mdx(\"p\", null, \"We start by copying the item at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" for further retrieval. The item at the\\nlast index is removed and it's contents are placed at index \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \". We then make\\nthis item \\\"swim down\\\" the tree to an appropriate location. The following video\\ndescribes the implemention in more detail.\"), mdx(\"p\", null, \"[VID]\"), mdx(\"h2\", null, \"Runtime\"), mdx(\"p\", null, \"Let's summarize the worst case runtimes of the operations of a min-heap and\\ncompare them to those of an ordered array and a bushy BST. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"add\"), \" and\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"removeSmallest\"), \" will take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(logN)\"), \" in the worst case (when we need to \\\"swim\\nup\\\" and \\\"swim down\\\" the entire depth of the tree). This runtime is actually\\namortized since the underlying array will need to be resized occasionally.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getSmallest\"), \" will take \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\u0398(1)\"), \" time.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Operation\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Ordered Array\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Bushy BST\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Heap\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"add\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"getSmallest\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(1)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(1)\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"removeSmallest\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\u0398(log N)\")))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"dffb28b9-19fe-5bc0-83d2-26cc7eaeb3e9","fields":{"slug":"/computer-science/courses/cs61b-data-structures/heaps-and-primary-queues/heaps-and-primary-queues","title":"Heaps and Primary Queues"}}}},{"contextLine":"- [[range-searching-and-multi-dimensional-data]]","targetAnchor":null,"refWord":"range-searching-and-multi-dimensional-data","target":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Range Searching and Multi Dimensional Data\"), mdx(\"h2\", null, \"Intro\"), mdx(\"p\", null, \"Let us consider a use case where we have a bunch of data points corresponding to\\nX-Y coordinates of celestial bodies orbiting a sun, and we need to calculate the\\nnumber of these bodies in a certain 2D range of coordinates, as shown below. Or\\nwe might need to find the closest body to a particular one.\"), mdx(\"p\", null, \"These operations can be listed as follows:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"2D range searching\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Nearest neighbors\")), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/9b2f4b4b1fa8c9e244adf09c80cb4ce2/bodies.png\",\n    \"alt\": \"bodies\"\n  }), \".\"), mdx(\"p\", null, \"If the data is stored as a hash table (the hashcode could be implemented using x\\nand y coordinates), both operations will be \\u0398(N), since we would have to iterate\\nover all items in the hash table. Let's simplify this problem by partitioning\\nthe 2D space into bins.\"), mdx(\"h2\", null, \"Uniform Partitioning\"), mdx(\"p\", null, \"The idea is to leverage the fact that by knowing the X and Y position, we can\\nknow which bucket of the hash table a particular point will fall in.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/1d31d2cff45810ed781f0963bcc1b5b4/bodies-partitioned.png\",\n    \"alt\": \"bodies-partitioned\"\n  })), mdx(\"p\", null, \"Assuming the points are evenly spread out, this would reduce the number of\\npoints we would have to look up for both operations. However, runtimes for\\nboth will still be \\u0398(N).\"), mdx(\"h2\", null, \"Trees vs Hash Tables\"), mdx(\"p\", null, \"Let's think about the nature of these two data structures for this particular\\nproblem. Search trees are all about order. As such, finding the minimum item in\\na BST is \\u0398(log(N)), whereas, it's \\u0398(N) in a hash table. We can make use of this\\nordered nature of search trees to improve the performance of the spatial\\noperations we're dealing with.\"), mdx(\"h2\", null, \"Building Trees of Two Dimensional Data\"), mdx(\"p\", null, \"We need some way to compare these 2D points for storing them in a BST. These\\npoints have X and Y coordinates, and we could either one of them to compare\\npoints. But, we would have to choose either one of them, and stick with it.\\nLet's consider an example of 2 2D points.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/f644baa90d9947f679b0b5a4297663b7/2d-bst.png\",\n    \"alt\": \"2d-bst\"\n  })), mdx(\"p\", null, \"Based on whether we're using X or Y coordinates to compare, we'd end up with\\neither one of the following BSTs.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/b141c504d2cceb658fa316d9f1a883ae/2d-trees.png\",\n    \"alt\": \"2d-trees\"\n  })), mdx(\"p\", null, \"With both BST, we lose some representation of the spatial structure (since we're\\nonly using one dimension).\"), mdx(\"p\", null, \"Let's see this in action. We'll see two trees representing a dataset of 6 2D\\npoints.\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"text\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-text\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-text\"\n  }, \"put((-1, -1), A)\\nput(( 2,  2), B)\\nput(( 0,  1), C)\\nput(( 1,  0), D)\\nput((-2, -2), E)\\nput((-3, 2.5), F)\"))), mdx(\"p\", null, \"Here's how they look in a 2D representation.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/10ea8ebd38de8b07db6e1e52aa71536d/6-points-2D.png\",\n    \"alt\": \"6-points-2D\"\n  })), mdx(\"p\", null, \"If we use the x-coordinate to compare, we get the following tree.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/b54d2b157544f0fbdae1cc139e304341/6-points-X-BST.png\",\n    \"alt\": \"6-points-X-BST\"\n  })), mdx(\"p\", null, \"This is better than the original hash table based approach for certain\\noperations. Suppose we want find out the points that have X coordinate less than\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-1.5\"), \". To do this we only need to look at the left hand child of the node \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A\"), \"\\nin the BST, and we can discard the right hand child completely. This process of\\ncutting off tree search is called \\\"pruning\\\".\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/406054405c7054a22aeb8fe8ad15db65/6-points-X-pruning.png\",\n    \"alt\": \"6-points-X-pruning\"\n  })), mdx(\"p\", null, \"However, this won't work if we build the BST by comparing Y coordinates.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/e5bf1d51ea299175c2a3a9308c2ff547/6-points-Y-pruning.png\",\n    \"alt\": \"6-points-Y-pruning\"\n  })), mdx(\"p\", null, \"This shows the limitations of using just one coordinate to build the BST.\\nFortunately, we can do better than this.\"), mdx(\"h2\", null, \"QuadTree\"), mdx(\"p\", null, \"We can improve on the previous idea by building a search tree where every node\\nhas 4 neighbors, corresponding to northwest, northeast, southwest, and southeast\\ndirections.\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vR79QZf2x_G4i8uTgbhTPL6__gXj4q_UohvBg42g0zYzyQLKal9MUqiCAGWsJg85BJ6l4CNhOt_P3fI/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"p\", null, \"As with regular BSTs, the order of insertion will determine the structure of the\\ntree. Quadtrees are, in fact, spatial partitioning in disguise. The previous\\napproach resulted in a uniform grid of rectangular regions, whereas we quadtrees\\nwe get what is called as hierarchical partitioning where each node \\\"owns\\\" 4\\nsubspaces.  Also, space is more finely divided in regions where there are more\\npoints.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/2c7f109d90b0bf5e5cf6bf48e57d8caf/quadtree-vs-uniform-partitioning.png\",\n    \"alt\": \"quadtree-vs-uniform-partitioning\"\n  })), mdx(\"h3\", null, \"Range Search\"), mdx(\"p\", null, \"Let's see how the quadtree helps us out with the range search operation.\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vThT7dHKwj-8Zxkhdl_sRjRroEGTwSoq8yqgBqyNMuou7QbsBfXxjaDC-ZQffdYz0emOFkpM637reEB/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"p\", null, \"As seen in the video, the structure of the quadtree enabled us to prune links\\nmuch more efficiently than the uniform partitioning approach.\"), mdx(\"h2\", null, \"KD Tree\"), mdx(\"p\", null, \"k-d trees are an extension of the previous idea, one that handles arbitray\\nnumber of dimensions. Let's see them in action using 2 dimensional data for the\\nsake of simplicity. \"), mdx(\"p\", null, \"For the case of 2 dimensions, the basic idea is that the root partitions the\\nentire space into left and right (ie, by the x dimension). All depth 1 nodes partition\\nthe subspace into up and down (ie, by the y dimension). We keep on cycling\\nthrough the dimensions at each subsequent level. \"), mdx(\"h3\", null, \"Insertion\"), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vTpwAIEkib5GO3gztO8kBGMseFofEiyhdV-ODGfhXUeBOPU1Gn3f-Z3mkKx5SffaxzJJmGDIrVpR4Sa/embed?start=false&loop=true&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }), mdx(\"p\", null, \"!!! note \\\"We have to break ties somehow. We'll do that by saying that items that are equal in one dimension go off to the right child of each node.\\\"\"), mdx(\"h3\", null, \"Nearest Neighbor\"), mdx(\"p\", null, \"Searching for a node in a k-d tree is similar to a quadtree, with the difference\\nthat each node in a k-d tree owns 2 subspaces instead of 4.\"), mdx(\"p\", null, \"The intuition for finding the nearest neighbor using a k-d tree is that at any\\nnode, we want to look at the \\\"good\\\" side of its subtree before looking at the\\n\\\"bad\\\" side.\"), mdx(\"p\", null, \"Let's understand that through a demo. Suppose we have the following k-d tree,\\nand we need to find the node nearest to the point (0, 7).\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/f9ed723b938b74ead2ce990878ea4f98/kd-tree-nearest-1.png\",\n    \"alt\": \"kd-tree-nearest-1\"\n  })), mdx(\"p\", null, \"The same tree in 2D representation is as follows.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/knowledge/1c5ed7461d2be9dfa2cd1f2fe4a06ff7/kd-tree-nearest-2.png\",\n    \"alt\": \"kd-tree-nearest-2\"\n  })), mdx(\"iframe\", {\n    src: \"https://docs.google.com/presentation/d/e/2PACX-1vT_7Xrc2N4rd9r6Otp2SFZGcUqICylgUenL6meBk-iLG3k9ep7uH35KkcsF7upHSwYv9lVU-9ecfriC/embed?start=false&loop=false&delayms=60000\",\n    frameBorder: \"0\",\n    width: \"960\",\n    height: \"569\",\n    allowFullScreen: \"true\",\n    mozallowfullscreen: \"true\",\n    webkitallowfullscreen: \"true\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"id":"5620fc6d-d945-5c3f-8536-fb390080d9a8","fields":{"slug":"/computer-science/courses/cs61b-data-structures/range-searching-and-multi-dimensional-data/range-searching-and-multi-dimensional-data","title":"Range Searching and Multi Dimensional Data"}}}}],"inboundReferences":[{"contextLine":"- [[cs61b-data-structures]]","referrer":{"parent":{"id":"6e3b1a2f-ed12-56b1-95cd-963d8452e58a","fields":{"slug":"/computer-science/courses/computer-science-courses","title":"CS Courses"}}}}]},"fields":{"slug":"/computer-science/courses/cs61b-data-structures/cs61b-data-structures","title":"CS61B Data Structures"}}},"pageContext":{"id":"7a2ed90b-bf85-5596-8620-2b3708fa9e83","refWordMdxSlugDict":{"asymptotics":"computer-science/courses/cs61b-data-structures/asymptotics/asymptotics","b-trees":"computer-science/courses/cs61b-data-structures/b-trees/b-trees","01-binary-search-trees":"computer-science/wiki/01-binary-search-trees","heaps-and-primary-queues":"computer-science/courses/cs61b-data-structures/heaps-and-primary-queues/heaps-and-primary-queues","range-searching-and-multi-dimensional-data":"computer-science/courses/cs61b-data-structures/range-searching-and-multi-dimensional-data/range-searching-and-multi-dimensional-data"}}},"staticQueryHashes":["2221750479","2380733210","2768355698","63159454","847517413"]}